<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>正为信息</title>
    <description>正为信息技术文章</description>
    <link>http://zw-tech.com/blog/</link>
    <atom:link href="http://zw-tech.com/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 02 Nov 2015 17:42:06 +0800</pubDate>
    <lastBuildDate>Mon, 02 Nov 2015 17:42:06 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>PID算法</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#pid&quot; id=&quot;markdown-toc-pid&quot;&gt;PID简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;数字形式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;算法流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pid&quot;&gt;PID简介&lt;/h2&gt;

&lt;p&gt;PID控制是目前工程上应用最广的一种控制方法，它的优点在于结构简单，且不依赖被控对象模型，控制所需的信息量也很少，因而非常易于工程实现，同时通过参数的调整也可获得较好的控制效果。
PID的三个参数——P（Proportional，比例）、I（Integration，积分）、D（Differentiation，微分）对时域响应的影响：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P—将误差信号放大或缩小，产生控制作用，以减小误差；&lt;/li&gt;
  &lt;li&gt;I—将误差不断累积，最终实现消除误差；&lt;/li&gt;
  &lt;li&gt;D—获取误差的微分信息，反映偏差的变化趋势（变化率），能在系统产生大的误差变化前产生控制作用，从而加快系统的响应，减小调节时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;框图如下图所示：
&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_4.jpg&quot; alt=&quot;pidScheme&quot; /&gt;&lt;br /&gt;
PID控制的是误差信号e(t) = r(t)-c(t)。PID控制律写成如下形式：
&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_1.gif&quot; alt=&quot;1&quot; /&gt;
或
&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_8.gif&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;数字形式&lt;/h2&gt;

&lt;p&gt;在计算机控制系统中采用的是数字PID，因为计算机控制实际上是采样控制，用一系列采样点kT表示连续时间t，用和式代表积分，用增量代替微分。数字PID有两种控制方式：位置式PID控制和增量式PID控制。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;位置式PID控制:&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_5.gif&quot; alt=&quot;3&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;增量式PID控制：&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_6.gif&quot; alt=&quot;4&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;位置式PID控制的输出与整个过去的状态有关，用的是误差的累加值；增量式PID的输出只与当前拍和前两拍的误差有关，因此，位置式PID控制的累积误差相对更大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增量式PID的输出的是控制量增量，并无积分作用，因此，这种方法适用于执行机构带积分部件的对象。如步进电机；而位置式PID适用于执行机构不带积分环节的对象，如电液伺服阀。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增量式PID输出的是控制量增量，若计算机出现故障，误动作影响较小，而执行机构本身有记忆功能，可仍保持原位，不会严重影响系统的工作，而位置式的输出直接对应对象的输出，因此对系统影响较大。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;算法流程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;增量式PID算法流程：&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_7.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;位置式PID算法流程：&lt;img src=&quot;http://zw-tech.com/blog/css/pics/pid_2.jpg&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Oct 2015 08:06:05 +0800</pubDate>
        <link>http://zw-tech.com/blog/2015/10/29/PID-controll-algorithm/</link>
        <guid isPermaLink="true">http://zw-tech.com/blog/2015/10/29/PID-controll-algorithm/</guid>
        
        
        <category>自动控制</category>
        
      </item>
    
      <item>
        <title>JavaScript 阶段总结</title>
        <description>&lt;p&gt;做了一张思维导图。总结这几个月对 JavaScript 的学习吧，也是一个复习。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7q5cdt.com1.z0.glb.clouddn.com/blog-JavaScriptNet2.png&quot; alt=&quot;JavaScriptNet&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 08:06:05 +0800</pubDate>
        <link>http://zw-tech.com/blog/2015/07/09/JavaScript-Net/</link>
        <guid isPermaLink="true">http://zw-tech.com/blog/2015/07/09/JavaScript-Net/</guid>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>JavaScript 面向对象</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;基于原型的继承&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#prototype-&quot; id=&quot;markdown-toc-prototype-&quot;&gt;prototype 属性与原型&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;例&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;原型链&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#objectcreatenull--bindnull&quot; id=&quot;markdown-toc-objectcreatenull--bindnull&quot;&gt;&lt;code&gt;Object.create(null)&lt;/code&gt; &amp;amp; &lt;code&gt;.bind(null)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#prototype--1&quot; id=&quot;markdown-toc-prototype--1&quot;&gt;prototype 属性&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#prototype&quot; id=&quot;markdown-toc-prototype&quot;&gt;改变 prototype&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#prototype--2&quot; id=&quot;markdown-toc-prototype--2&quot;&gt;内置构造器的 &lt;code&gt;prototype&lt;/code&gt; 属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#new&quot; id=&quot;markdown-toc-new&quot;&gt;创建对象-new/原型链&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#instanceof&quot; id=&quot;markdown-toc-instanceof&quot;&gt;instanceof&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;实现继承的方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;模拟重载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;调用子类方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;链式调用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;抽象类&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;模块化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文为慕课网 &lt;a href=&quot;http://www.imooc.com/learn/277&quot;&gt;JavaScript深入浅出&lt;/a&gt; 笔记。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;概念&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;面向对象程序设计（Object-oriented programming，OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。&lt;/p&gt;

  &lt;p&gt;——维基百科&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般面向对象包含：继承，封装，多态，抽象&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基于原型的继承&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
    this.y = 2;
}
console.log(typeof Foo.prototype); //object

Foo.prototype.x = 1;
var obj3 = new Foo();

console.log(obj3.y); //2
console.log(obj3.x); //1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建函数 &lt;code&gt;Foo&lt;/code&gt; 的时候，就会有一个内置的 &lt;code&gt;Foo.prototype&lt;/code&gt; 属性，并且这个属性是对象。&lt;/p&gt;

&lt;p&gt;在使用 &lt;code&gt;new Foo();&lt;/code&gt; 创建对象实例时。&lt;code&gt;this&lt;/code&gt; 会指向一个对象，并且这个对象的原型会指向 &lt;code&gt;Foo.prototype&lt;/code&gt; 属性。&lt;code&gt;this.y = 2&lt;/code&gt; 给这个对象赋值，并把这个对象返回。把这个对象赋值给 &lt;code&gt;obj3&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;obj3&lt;/code&gt; 上的，&lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;obj3&lt;/code&gt; 的原型 &lt;code&gt;Foo.prototype&lt;/code&gt; 上的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7q5cdt.com1.z0.glb.clouddn.com/blog-prototype.png&quot; alt=&quot;prototype&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;prototype-&quot;&gt;prototype 属性与原型&lt;/h3&gt;

&lt;p&gt;prototype 是函数对象上预设的对象属性。&lt;/p&gt;

&lt;p&gt;原型是对象上的原型，通常是构造器的 prototype 属性。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;例&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.LEGS_NUM = 2;
Person.prototype.ARMS_NUM = 2;

Person.prototype.hi = function() {
    console.log(&#39;Hi, my name is &#39; + this.name + &quot;. I&#39;m &quot; + this.age + &#39; years old now&#39;);
};

Person.prototype.walking = function() {
    console.log(this.name + &#39; is walking...&#39;);
};

function Student(name, age, className) {
    Person.call(this, name, age); //使 Person 中的 this 指向 Student
    this.className = className;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.hi = function() {
    console.log(&#39;Hi, my name is &#39; + this.name + &quot;. I&#39;m &quot; + this.age + &#39; years old now, and from &#39; + this.className + &quot;.&quot;);
};

Student.prototype.learn = function(subject) {
    console.log(this.name + &#39; is learning &#39; + subject + &#39; at &#39; + this.className + &#39;.&#39;);
}

//test
var gao = new Student(&#39;Gao&#39;, &#39;24&#39;, &#39;Class 3123&#39;);
console.log(gao); // 这个对象的具体内容见下图
gao.hi(); //Hi, my name is Gao. I&#39;m 24 years old now, and from Class 3123.
gao.LEGS_NUM; //2
gao.walking(); //Gao is walking...
gao.learn(&#39;JavaScript&#39;); //Gao is learning JavaScript at Class 3123.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Object.create(arg)&lt;/code&gt; 创建一个空对象，并且这个对象的原型指向参数 &lt;code&gt;arg&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Student.prototype.constructor = Student&lt;/code&gt; 为了保证一致性，否则 constructor 指向 Person。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;原型链&lt;/h3&gt;

&lt;p&gt;gao 对象的原型链：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7q5cdt.com1.z0.glb.clouddn.com/blog-oop-gao.png&quot; alt=&quot;Object&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面通过图形展示原型链：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7q5cdt.com1.z0.glb.clouddn.com/blog-原型链.png&quot; alt=&quot;原型链&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;objectcreatenull--bindnull&quot;&gt;&lt;code&gt;Object.create(null)&lt;/code&gt; &amp;amp; &lt;code&gt;.bind(null)&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;这两种算是特例。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.create(null)&lt;/code&gt; 和 &lt;code&gt;.bind(null)&lt;/code&gt; 这两种方式创建出来的对象是没有 &lt;code&gt;prototype&lt;/code&gt; 属性的，为 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;prototype--1&quot;&gt;prototype 属性&lt;/h2&gt;

&lt;h3 id=&quot;prototype&quot;&gt;改变 prototype&lt;/h3&gt;

&lt;p&gt;JavaScript 中的 prototype 是对象，在运行的时候可以修改。&lt;/p&gt;

&lt;p&gt;给 prototype 添加或删除一些属性，是会影响到已经创建好的实例对象的。&lt;/p&gt;

&lt;p&gt;但是，直接修改 prototype 属性，是不会影响到已经创建好的实例对象的。但是会影响到新的实例对象。如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 上接上面的代码

// 给 prototype 添加或删除一些属性
Student.prototype.x = 101;
console.log(gao.x); //101

// 直接修改 prototype 属性
Student.prototype = {
    y: 2
};

// 不会影响到已创建好的实例对象
console.log(gao.x); //101
console.log(gao.y); //undefined

// 会影响到新创建的实例对象
var ying = new Student(&#39;Ying&#39;, 24, &#39;UI&#39;);
console.log(ying.x); //undefined
console.log(ying.y); //2
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;prototype--2&quot;&gt;内置构造器的 &lt;code&gt;prototype&lt;/code&gt; 属性&lt;/h3&gt;

&lt;p&gt;修改内置构造器的 &lt;code&gt;prototype&lt;/code&gt; 属性后，在实例化这个对象后，枚举其属性时，会把修改的内置构造器的 &lt;code&gt;prototype&lt;/code&gt; 属性也枚举出来，有时候这是要避免的。可用 &lt;code&gt;defineProperty&lt;/code&gt; 方法解决。如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.prototype.x = 1;
var obj = {};
console.log(obj.x); //1
console.log(obj);

for (var k in obj) {
    console.log(&#39;result---&amp;gt;&#39; + k);
}
// result---&amp;gt;x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;defineProperty&lt;/code&gt; 后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.defineProperty(Object.prototype, &#39;x&#39;, {
    writable: true,
    value: 1
});
var obj = {};
console.log(obj.x);//1
console.log(obj);
for (var k in obj) {
    console.log(&#39;result---&amp;gt;&#39; + k);
}
// nothing output here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实也可以这样枚举，使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
        console.log(&quot;result---&amp;gt;&quot; + key);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;new&quot;&gt;创建对象-new/原型链&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://7q5cdt.com1.z0.glb.clouddn.com/blog-new prototype.png&quot; alt=&quot;prototype&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;instanceof&quot;&gt;instanceof&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;console.log([1, 2] instanceof Array); //true
console.log([1, 2] instanceof Object); //true
console.log(new Object() instanceof Array); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左边要求是对象，右边要求是构造器或函数。它会判断：&lt;strong&gt;右边的构造器中的 &lt;code&gt;prototype&lt;/code&gt; 属性是否出现在左边的对象的原型链上。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt;不同的 window 或 iframe 间的对象类型检测&lt;strong&gt;不能&lt;/strong&gt;使用 &lt;code&gt;instanceof&lt;/code&gt;！&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;实现继承的方式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person() {}

function Student() {}

Student.prototype = Person.prototype; //1

Student.prototype = new Person(); //2

Student.prototype = Object.create(Person.prototype); //3

Student.prototype.constructor = Student;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释中：&lt;/p&gt;

&lt;p&gt;1 是错误的。如果改变了 Student 就会改变 Person&lt;/p&gt;

&lt;p&gt;2 可以实现继承，但是其调用了构造函数，若父类构造函数中有形参，那么传值就会比较奇怪。&lt;/p&gt;

&lt;p&gt;3 是最好的方法。创建了一个空对象，并且对象的原型指向参数 Person.prototype。这样便实现了继承。同时原型链写，不向上查找。但是 &lt;code&gt;Object.create&lt;/code&gt; 是ES5 中的方法，所以可以使用下列代码做兼容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function(proto) {
        function F() {}
        F.prototype = proto;
        return new F;
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-5&quot;&gt;模拟重载&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person() {
    var args = arguments;
    if (typeof args[0] === &#39;object&#39; &amp;amp;&amp;amp; args[0]) {
        if (args[0].name) {
            this.name = args[0].name;
        }
        if(args[0].age){
            this.age = args[0].age;
        }
    } else {
        if (args[0]) {
            this.name = args[0];
        }
        if (args[1]) {
            this.age = args[1];
        }
    }
}

//重写 toString 方法
Person.prototype.toString = function() {
    console.log(&#39;name=&#39;+this.name+&#39;, age=&#39;+this.age);
};

var gao = new Person({name:&#39;Gao&#39;,age:24});
gao.toString(); // name=Gao, age=24

var ying = new Person(&#39;Ying&#39;,25);
ying.toString(); // name=Ying, age=25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对参数进行判断，模拟实现重载。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-6&quot;&gt;调用子类方法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name) {
    this.name = name;
}

function Student(name, className) {
    this.className = className;
    Person.call(this, name); // 调用基类的构造器
}

var gao = new Student(&#39;Gao&#39;, &#39;3123&#39;);
console.log(gao); // Student {className: &quot;3123&quot;, name: &quot;Gao&quot;}

Person.prototype.init = function() {};

Student.prototype.init = function() {
    // do sth...
    Person.prototype.init.apply(this, arguments); // 同时也想调用父类被覆盖的方法
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是两种：调用父类的构造器，调用原型链上父类被覆盖的方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;链式调用&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function ClassManager() {}
ClassManager.prototype.addClass = function(str) {
    console.log(&#39;Class: &#39; + str + &#39; added&#39;);
    return this;
};

var manager = new ClassManager();
manager.addClass(&#39;classA&#39;).addClass(&#39;classB&#39;).addClass(&#39;classC&#39;);
// Class: classA added
// Class: classB added
// Class: classC added
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点在于 return this。返回这个 ClassManager 的实例。这样这个实例又可以继续调用方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-8&quot;&gt;抽象类&lt;/h2&gt;

&lt;p&gt;在构造器中 &lt;code&gt;throw new Error(&#39;&#39;);&lt;/code&gt; 抛异常。这样防止这个类被直接调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function DetectorBase() {
    throw new Error(&#39;Abstract class can not be invoked directly!&#39;);
}

DetectorBase.detect = function() {
    console.log(&#39;Detection starting...&#39;);
}
DetectorBase.stop = function() {
    console.log(&#39;Detection stopped.&#39;);
};
DetectorBase.init = function() {
    throw new Error(&#39;Error&#39;);
}

var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!

function LinkDetector() {}
LinkDetector.prototype = Object.create(DetectorBase.prototype);
LinkDetector.prototype.constructor = LinkDetector;

var l = new LinkDetector();
console.log(l); //LinkDetector {}__proto__: LinkDetector
l.detect(); //Uncaught TypeError: l.detect is not a function
l.init(); //Uncaught TypeError: l.init is not a function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;var d = new DetectorBase();&lt;/code&gt; 是不能实例化的，会报错&lt;/p&gt;

&lt;p&gt;&lt;code&gt;l.detect();&lt;/code&gt; 但是这个为什么报错我就不知道了。&lt;/p&gt;

&lt;p&gt;已经在原课程下提问了，期待老师的讲解。 &lt;a href=&quot;http://www.imooc.com/qadetail/82732&quot;&gt;抽象类中子类为什么不能调用父类的非抽象方法？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;问题已经解决了，应该是老师当时的课件写错了，应该再基类中将这两个方法写在其原型 prototype 上。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function DetectorBase() {
    throw new Error(&#39;Abstract class can not be invoked directly!&#39;);
}

DetectorBase.prototype.detect = function() {
    console.log(&#39;Detection starting...&#39;);
};
DetectorBase.prototype.stop = function() {
    console.log(&#39;Detection stopped.&#39;);
};
DetectorBase.prototype.init = function() {
    throw new Error(&#39;Error&#39;);
};

// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!

function LinkDetector() {}
LinkDetector.prototype = Object.create(DetectorBase.prototype);
LinkDetector.prototype.constructor = LinkDetector;

var l = new LinkDetector();
console.log(l); //LinkDetector {}__proto__: LinkDetector
l.detect(); //Detection starting...
l.init(); //Uncaught Error: Error
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-9&quot;&gt;模块化&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var moduleA;
moduleA = function() {
    var prop = 1;

    function func() {}
    
    return {
        func: func,
        prop: prop
    };
}(); // 立即执行匿名函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prop，func 不会被泄露到全局作用域。&lt;/p&gt;

&lt;p&gt;或者另一种写法，使用 new&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;moduleA = new function() {
    var prop = 1;

    function func() {}
    
    this.func = func;
    this.prop = prop;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更复杂的可以使用 Sea.js Kissy Require.js 模块化工具。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后补充一点设计模式相关的资料，我还没有来得及看的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.oschina.net/translate/learning-javascript-design-patterns&quot;&gt;学用 JavaScript 设计模式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/29454/&quot;&gt;常用的Javascript设计模式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.51cto.com/art/201109/288650_all.htm&quot;&gt;JavaScript设计模式深入分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 22:06:05 +0800</pubDate>
        <link>http://zw-tech.com/blog/2015/06/15/JavaScript-Object-Oriented/</link>
        <guid isPermaLink="true">http://zw-tech.com/blog/2015/06/15/JavaScript-Object-Oriented/</guid>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>JavaScript 中的闭包</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;闭包的例子&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;常见错误之循环闭包&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;封装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文为慕课网 &lt;a href=&quot;http://www.imooc.com/learn/277&quot;&gt;JavaScript深入浅出&lt;/a&gt; 笔记。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;闭包的例子&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function outer() {
    var localVal = 30;
    return localVal;
}

console.log(outer()); //30

function outer2() {
    var localVal = 30;
    return function() {
        return localVal;
    };
}

var func = outer2();
console.log(func()); //30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于第一个普通的函数，在执行过之后，它的局部变量就可以被释放。&lt;/p&gt;

&lt;p&gt;对于第二个函数，&lt;code&gt;localVal&lt;/code&gt; 是不能被释放的。因为调用 &lt;code&gt;outer2()&lt;/code&gt; 后，返回的是匿名函数，匿名函数可以访问外部的 &lt;code&gt;outer2()&lt;/code&gt; 中的局部变量，并返回了这个局部变量 localVal。当 &lt;code&gt;outer2()&lt;/code&gt; 赋值给 &lt;code&gt;func&lt;/code&gt; 后，再次调用 &lt;code&gt;func()&lt;/code&gt;，仍能访问到局部变量 &lt;code&gt;localVal&lt;/code&gt;。这种情况就是闭包。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;应用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;所谓闭包就是：子函数可以使用父函数中的局部变量。&lt;/strong&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  ! function() {
      var localData = &quot;localData here&quot;;
      document.addEventListener(&#39;click&#39;,
          function() {
              console.log(localData); //这里访问外部数据
          });
  }();

  ! function() {
      var localData = &quot;localData here&quot;;
      var url = &quot;http://www.baidu.com/&quot;;
      $.ajax({
          url: url,
          success: function() {
              // do sth...
              console.log(localData); //这里访问外部数据
          }
      });
  }()
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常见错误之循环闭包&lt;/h2&gt;

&lt;p&gt;比如我们想循环绑定点击事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.body.innerHTML = &quot;&amp;lt;div id=div1&amp;gt;aaa&amp;lt;/div&amp;gt;&amp;lt;div id=div2&amp;gt;bbb&amp;lt;/div&amp;gt;&amp;lt;div id=div3&amp;gt;ccc&amp;lt;/div&amp;gt;&quot;;
for (var i = 1; i &amp;lt; 4; i++) {
    document.getElementById(&#39;div&#39; + i).
    addEventListener(&#39;click&#39;, function() {
        alert(i); // all are 4!
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，我们点击任何一个 div，弹出的都是 4&lt;/p&gt;

&lt;p&gt;这是因为，for 循环中的 i 是一个全局变量。这里内函数的点击事件，访问到的是循环后的 i 值，所以是 4&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.body.innerHTML = &quot;&amp;lt;div id=div1&amp;gt;aaa&amp;lt;/div&amp;gt;&amp;lt;div id=div2&amp;gt;bbb&amp;lt;/div&amp;gt;&amp;lt;div id=div3&amp;gt;ccc&amp;lt;/div&amp;gt;&quot;;
for (var i = 1; i &amp;lt; 4; i++) {
    ! function(i) {
        document.getElementById(&#39;div&#39; + i).
        addEventListener(&#39;click&#39;, function() {
            alert(i); // 1, 2, 3
        });
    }(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了立即执行函数，并给匿名函数赋值 i，这样点击事件每一次就会访问到相应的 i。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;封装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;(function() {
    var _userId = 9527;
    var _typeId = &quot;item&quot;;
    var exp = {};

    function converter(userId) {
        return +userId;
    }

    exp.getUserId = function() {
        return converter(_userId);
    };

    exp.getTypeId = function() {
        return _typeId;
    };

    window.a = exp;
})();

console.log(a.getUserId()); //9527
console.log(a.getTypeId()); //item

console.log(a._userId); //undefined
console.log(a._typeId); //undefined
console.log(converter); //Uncaught ReferenceError: converter is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码通过闭包实现了一个封装。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;from 维基百科&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;闭包的优点
    &lt;ul&gt;
      &lt;li&gt;灵活和方便&lt;/li&gt;
      &lt;li&gt;封装&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点
    &lt;ul&gt;
      &lt;li&gt;空间浪费&lt;/li&gt;
      &lt;li&gt;内存泄露&lt;/li&gt;
      &lt;li&gt;性能消耗&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 14 Jun 2015 22:06:05 +0800</pubDate>
        <link>http://zw-tech.com/blog/2015/06/14/JavaScript-closure/</link>
        <guid isPermaLink="true">http://zw-tech.com/blog/2015/06/14/JavaScript-closure/</guid>
        
        
        <category>通信技术</category>
        
      </item>
    
      <item>
        <title>JavaScript 中的 this</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#this&quot; id=&quot;markdown-toc-this&quot;&gt;全局的 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-1&quot; id=&quot;markdown-toc-this-1&quot;&gt;一般函数的 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-2&quot; id=&quot;markdown-toc-this-2&quot;&gt;作为对象方法的函数的 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-3&quot; id=&quot;markdown-toc-this-3&quot;&gt;对象原型链上的 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#getset--this&quot; id=&quot;markdown-toc-getset--this&quot;&gt;get/set 方法与 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#this-4&quot; id=&quot;markdown-toc-this-4&quot;&gt;构造器中的 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#callapply--this&quot; id=&quot;markdown-toc-callapply--this&quot;&gt;call/apply 方法与 this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bind--this&quot; id=&quot;markdown-toc-bind--this&quot;&gt;bind 方法与 this&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文为慕课网 &lt;a href=&quot;http://www.imooc.com/learn/277&quot;&gt;JavaScript深入浅出&lt;/a&gt; 笔记。&lt;/p&gt;

&lt;h2 id=&quot;this&quot;&gt;全局的 this&lt;/h2&gt;

&lt;p&gt;全局 this 一般指向全局对象，浏览器中的全局对象就是 &lt;code&gt;window&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(this.document === document); //true
console.log(this === window); //true

this.a = 91;
console.log(window.a); //91
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;this-1&quot;&gt;一般函数的 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function f1 () {
    return this;
}
console.log(f1() === window);//true, global object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到一般函数的 this 也指向 window，在 nodeJS 中为 global object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function f2 () {
    &quot;use strict&quot;;//使用严格模式
    return this;
}
console.log(f1() === undefined);//true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;严格模式中，函数的 this 为 undefined&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;this-2&quot;&gt;作为对象方法的函数的 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var o = {
    prop: 37,
    f: function() {
        return this.prop;
    }
};
console.log(o.f()); // 37
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码通过字面量创建对象 o。&lt;/p&gt;

&lt;p&gt;f 为对象 o 的方法。这个方法的 this 指向这个对象，在这里即对象 o。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = {
    prop: 37
};

function independent() {
    return this.prop;
}
o.f = independent;
console.log(o.f()); // 37
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，创建了对象 o，但是没有给对象 o，添加方法。而是通过 &lt;code&gt;o.f = independent&lt;/code&gt; 临时添加了方法属性。这样这个方法中的 this 同样也指向这个对象 o。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;this-3&quot;&gt;对象原型链上的 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var o = {
    f: function() {
        return this.a + this.b;
    }
};
var p = Object.create(o);
p.a = 1;
p.b = 2;
console.log(p.f()); //3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;var p = Object.create(o)&lt;/code&gt; 创建的对象，p 是基于原型 o 创建出的对象。&lt;/p&gt;

&lt;p&gt;p 的原型是 o，调用 f() 的时候是调用了 o 上的方法 f()，这里面的 this 是可以指向当前对象的，即对象 p。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;getset--this&quot;&gt;get/set 方法与 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function modulus() {
    return Math.sqrt(this.re * this.re + this.im * this.im);
}
var o = {
    re: 1,
    im: -1,
    get phase() {
        return Math.atan2(this.im, this.re);
    }
};
Object.defineProperty(o, &#39;modulus&#39;, {
    get: modulus,
    enumerable: true,
    configurable: true
});
console.log(o.phase, o.modulus); // -0.78 1.4142
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get/set 方法中的 this 也会指向 get/set 方法所在的对象的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;this-4&quot;&gt;构造器中的 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function MyClass() {
    this.a = 25;
}
var o = new MyClass();
console.log(o.a); //25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new MyClass() 的时候，MyClass()中的 this 会指向一个空对象，这个对象的原型会指向 MyClass.prototype。MyClass()没有返回值或者返回为基本类型时，默认将 this 返回。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function C2() {
    this.a = 26;
    return {
        a: 24
    };
}

o = new C2();
console.log(o.a); //24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为返回了对象，将这个对象作为返回值&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;callapply--this&quot;&gt;call/apply 方法与 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function add(c, d) {
    return this.a + this.b + c + d;
}
var o = {
    a: 1,
    b: 3
};
add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
function bar() {
    console.log(Object.prototype.toString.call(this));
}
bar.call(7); // &quot;[object Number]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;bind--this&quot;&gt;bind 方法与 this&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function f() {
    return this.a;
}
var g = f.bind({
    a: &quot;test&quot;
});
console.log(g()); // test
var o = {
    a: 37,
    f: f,
    g: g
};
console.log(o.f(), o.g()); // 37, test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定之后再调用时，仍然会按绑定时的内容走，所以 o.g() 结果是 test&lt;/p&gt;

</description>
        <pubDate>Fri, 12 Jun 2015 22:06:05 +0800</pubDate>
        <link>http://zw-tech.com/blog/2015/06/12/JavaScript-this/</link>
        <guid isPermaLink="true">http://zw-tech.com/blog/2015/06/12/JavaScript-this/</guid>
        
        
        <category>硬件技术</category>
        
      </item>
    
      <item>
        <title>JavaScript 函数</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;概念&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;调用方式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;函数声明与函数表达式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;函数声明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;函数表达式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;变量 &amp;amp; 函数的声明前置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#function-&quot; id=&quot;markdown-toc-function-&quot;&gt;Function 构造器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;对比&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#arguments&quot; id=&quot;markdown-toc-arguments&quot;&gt;函数属性 &amp;amp; arguments&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#arguments-1&quot; id=&quot;markdown-toc-arguments-1&quot;&gt;函数属性 &amp;amp; arguments&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#applycall-&quot; id=&quot;markdown-toc-applycall-&quot;&gt;apply/call 方法（浏览器）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#bind-&quot; id=&quot;markdown-toc-bind-&quot;&gt;bind 方法&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#bind--currying&quot; id=&quot;markdown-toc-bind--currying&quot;&gt;bind 与 currying&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#bind--new&quot; id=&quot;markdown-toc-bind--new&quot;&gt;bind 与 new&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文为慕课网 &lt;a href=&quot;http://www.imooc.com/learn/277&quot;&gt;JavaScript深入浅出&lt;/a&gt; 笔记。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;函数是一块JavaScript代码，被定义一次，但可执行和调用多次。&lt;/p&gt;

&lt;p&gt;JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递。&lt;/p&gt;

&lt;p&gt;所以我们也常叫JS中的函数为函数对象。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(x, y) {
    if (typeof x === &#39;number&#39; &amp;amp;&amp;amp;
        typeof y === &#39;number&#39;) {
        return x + y;
    } else {
        return 0;
    }
}
foo(1, 2); // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般由3部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数名&lt;/li&gt;
  &lt;li&gt;参数列表&lt;/li&gt;
  &lt;li&gt;函数体&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;调用方式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接调用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  foo();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对象方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  o.method();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构造器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  new Foo();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;call/apply/bind&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  func.call(o);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;函数声明与函数表达式&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;函数声明&lt;/h3&gt;

&lt;p&gt;就是对函数进行普通的声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add(a, b) {
    return a + b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;函数表达式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将函数赋值给变量&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  //function variable
  var add = function(a, b) {
      // body...
  };
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;立即执行函数&lt;/p&gt;

    &lt;p&gt;把匿名函数用括号括起来，再直接调用。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  // IEF(Immediately Executed Function)
  (function() {
      // body...
  })();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数对象作为返回值&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  return function() {
      // body...
  };
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命名式函数表达式&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  //NFE(Named Function Expression)
  var add = function foo(a, b) {
      // body...
  };
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这里大家肯定会好奇，这个函数怎么调用？到底用哪个名字呢？&lt;/p&gt;

    &lt;p&gt;做一个测试：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  var func = function nfe() {};
  console.log(func === nfe);
  // 在 IE6~8，得到 false
  // 在 IE9+ 及现代浏览器中 Uncaught ReferenceError: nfe is not defined
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;那么命名函数表达式有什么使用场景呢？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。&lt;/li&gt;
      &lt;li&gt;或者在递归时，使用名字调用自己。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;但是这两种用法都不常见。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;变量 &amp;amp; 函数的声明前置&lt;/h3&gt;

&lt;p&gt;举两个例子&lt;/p&gt;

&lt;p&gt;例1，函数声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var num = add(1,2);
console.log(num);

function add(a, b) {
    return a + b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例2，函数表达式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var num = add(1, 2);
console.log(num);

var add = function(a, b) {
    return a + b;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例1中得到的结果是 3，而例2中是 &lt;code&gt;Uncaught TypeError: add is not a function&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因为函数和变量在声明的时候，会被前置到当前作用域的顶端。例1将函数声明 &lt;code&gt;function add(a, b)&lt;/code&gt; 前置到作用域前端，例2将声明 &lt;code&gt;var add&lt;/code&gt; 前置到其作用域的前端了，并没有赋值。&lt;strong&gt;赋值的过程是在函数执行到响应位置的时候才进行的&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;function-&quot;&gt;Function 构造器&lt;/h3&gt;

&lt;p&gt;除了函数声明、函数表达式。还有一种创建函数对象的方式，是使用函数构造器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var func = new Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a+b);&#39;);
func(1,2);//3

var func2 = Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a+b);&#39;);
func2(1,2);//3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。&lt;/p&gt;

&lt;p&gt;还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-6&quot;&gt;对比&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://7q5cdt.com1.z0.glb.clouddn.com/blog-function.png&quot; alt=&quot;函数对比&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;arguments&quot;&gt;函数属性 &amp;amp; arguments&lt;/h2&gt;

&lt;h3 id=&quot;arguments-1&quot;&gt;函数属性 &amp;amp; arguments&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function foo(x, y, z) {
    arguments.length; // 2
    arguments[0]; // 1
    arguments[0] = 10;
    x; // change to 10

    arguments[2] = 100;
    z; // still undefined!!!
    arguments.callee === foo; // true
}

foo(1, 2);
foo.length; // 3
foo.name; //&quot;foo&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;foo.name&lt;/code&gt; 函数名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;foo.length&lt;/code&gt; 形参个数&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;arguments.length&lt;/code&gt; 实参个数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;未传参数时，arguments[i] 相应的位置仍然是 undefined。&lt;/p&gt;

&lt;p&gt;严格模式下，代码中的改变实参失效。即 x 仍为 1。同时 callee 属性失效。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关于 &lt;code&gt;callee&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;callee 属性的初始值就是正被执行的 Function 对象。&lt;/p&gt;

    &lt;p&gt;callee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或者保证函数的封装性，例如下边示例的递归计算1到n的自然数之和。而该属性仅当相关函数正在执行时才可用。还有需要注意的是callee拥有length属性，这个属性有时用于验证还是比较好的。&lt;/p&gt;

    &lt;p&gt;arguments.length是实参长度，arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;applycall-&quot;&gt;apply/call 方法（浏览器）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function foo(x, y) {
    console.log(x, y, this);
}

foo.call(100, 1, 2); //1 2 Number {[[PrimitiveValue]]: 100}
foo.apply(true, [3, 4]); //3 4 Boolean {[[PrimitiveValue]]: true}
foo.apply(null); //undefined undefined Window
foo.apply(undefined); //undefined undefined Window
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;call/apply 的作用：调用一个对象的一个方法，以另一个对象替换当前对象(其实就是更改对象的内部指针，即改变对象的this指向的内容)。&lt;/li&gt;
  &lt;li&gt;call/apply 的第一个参数为对象，即使不是对象，也会被包装为对象。&lt;/li&gt;
  &lt;li&gt;call 为扁平化传参，apply 后面的参数为数组&lt;/li&gt;
  &lt;li&gt;传入 null/undefined 时，实际为 Window 对象&lt;/li&gt;
  &lt;li&gt;在严格模式下：上述代码最后两行分别输出 &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bind-&quot;&gt;bind 方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 是 ES5 中提出的方法，所以浏览器支持为 IE9+ 及现代浏览器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.x = 9;
var module = {
    x: 81,
    getX: function() {
        return console.log(this.x);
    }
};

module.getX(); //81

var getX = module.getX;
getX(); //9

var boundGetX = getX.bind(module);
boundGetX(); //81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 主要用于改变函数中的 &lt;code&gt;this&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;module.getX(); &lt;/code&gt; 直接通过对象调用自己的方法，结果是 81&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var getX = module.getX;&lt;/code&gt; 将这个方法赋值给一个全局变量，这时 this 指向了 Window，所以结果为 9&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var boundGetX = getX.bind(module);&lt;/code&gt; 使用 bind 绑定了自己的对象，这样 this 仍然指向 module 对象，所以结果为 81&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;bind--currying&quot;&gt;bind 与 currying&lt;/h4&gt;

&lt;p&gt;bind 可以使函数柯里化，那么什么是柯里化？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function add(a, b, c) {
    return a + b + c;
}

var func = add.bind(undefined, 100);
func(1, 2); //103

var func2 = func.bind(undefined, 200);
func2(10); //310
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;add 函数拥有 3 个参数。我们想先传入一个参数，再去传其他参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var func = add.bind(undefined, 100);&lt;/code&gt; add 函数对象调用 bind 方法，由于不需要将 this 指向原来的 add 函数对象，所以第一个参数写为 undefined 或 null。第二个参数 100 传给了 add 函数中的形参 a，并赋值给一个新的函数对象 func。&lt;/p&gt;

&lt;p&gt;这时，&lt;code&gt;func(1, 2)&lt;/code&gt; 即相当于传入后两个参数，所以结果为 103。&lt;/p&gt;

&lt;p&gt;同理，基于 func 可以创造一个函数 func2。它只用传最后一个参数。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;bind--new&quot;&gt;bind 与 new&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    this.b = 100;
    return this.a;
}

console.log(foo()); //undefined

var func = foo.bind({
    a: 1
});

console.log(func()); //1
console.log(new func()); //foo {b: 100}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用了 &lt;code&gt;new func()&lt;/code&gt; 这种方式创建对象，其返回值为一个对象。&lt;/p&gt;

&lt;p&gt;而原函数 foo 的返回值不是对象，所以会直接忽视这个 return 方法。而是变为 &lt;code&gt;return this;&lt;/code&gt;。并且 this 会被初始化为一个空对象，这个空对象的原型指向 foo.prototype。所以后面的 bind 是不起作用的。&lt;/p&gt;

&lt;p&gt;这里面这个 this 对象包含一个属性 &lt;code&gt;b = 100&lt;/code&gt;。所以返回的是对象 &lt;code&gt;{b: 100}&lt;/code&gt;。&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Jun 2015 22:06:05 +0800</pubDate>
        <link>http://zw-tech.com/blog/2015/06/11/JavaScript-function/</link>
        <guid isPermaLink="true">http://zw-tech.com/blog/2015/06/11/JavaScript-function/</guid>
        
        
        <category>编程语言</category>
        
      </item>
    
  </channel>
</rss>
